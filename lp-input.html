<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/core-ajax/core-ajax.html">

<!--
lp-input is a custom "fake input" to search users, hashtags by ajax and to 
format the content by using ordinary div#editable. Works like twitter, facebook,
slack inputs.

##### Example
      <div id="editable" contenteditable="true">
      </div>
      <lp-input target="editable"></lp-input>

@element lp-input
@blurb Element providing a ghost operator that makes input like twitter
@status beta
@homepage http://github.com/horacioibrahim/lp-input
-->

<polymer-element name="lp-input" attributes="target mentionsURL">
  <template>

      <link rel="stylesheet" href="lp-input.css">

      <!-- dropdown list of users 
           init search by @na...
      -->
      <div id="mentionsContainer">
          <ul id="ulMentionsContainer">
            <template repeat="{{user in responseUsers.Users }}">
              <li on-click="{{ selectedUser }}" data-shortname="{{ user.shortname }}"
              data-location="{{ user.location }}" data-avatar="{{ user.avatar }}">
                  <div class="mentions">
                      <div class="avatar">
                          <img src="{{user.avatar}}">
                      </div>
                      <div class="info">
                        <div class="username">{{ user.shortname }}</div>
                        <div class="details">{{ user.location }}</div> 
                      </div>
                  </div>          
              </li> 
            </template>
          </ul>
      </div>

      <!-- dropdown list of hashtags -->
      <div class="hashtags"></div>

      <!-- This elements will be a copy of the contentEditable passed by user. --> 
      <div id="editableFilter" contenteditable="true" hidden>
        <br/>
      </div> 

      <!-- ajax -->
      <core-ajax auto id="mentionsAjax" url="{{ mentionsURL }}"
      response="{{responseUsers}}"></core-ajax>
      
      <core-ajax id="tagsAjax" url="{{ tagsURL }}" response="{{responseTags}}"></core-ajax>


  </template>
  <script>
    (function () {
      Polymer('lp-input', {
        /**
        * Fired when a user is selected in mentions box.
        *
        * @event selected-user
        */        
        publish: {
          /**
          * The target is ID's value of the div.contentEditable.
          *
          * @attribute target
          * @type string
          * @default 'editable'
          */          
          target: "editable",
          __targetElem: null,
          tagRegex: /(#){1}([A-Z]+[A-Z0-9]+)/ig,
          userRegex: /(@){1}([A-Z]+[A-Z0-9]+)/ig,
          linkRegex: /https?:\/\/(www\.)?[-a-z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-z0-9@:%_\+.~#?&\/=]*)?/ig,
          isNewNode: false
        },    
        ready: function () {
          // get the div#editable passed by user
          this._targetElem = document.querySelector('#' + this.target);
          // get current custom element object
          var fakeThis = document.querySelector('lp-input');
          // listen by inputs
          this._targetElem.addEventListener('input', function() {
             fakeThis.checkInput();         
          });  
          // liste by keydown to handling <space>, <backspace>, <ctrl+z>, etc.
          this._targetElem.addEventListener('keydown', function(e) {
            fakeThis.keysPressed(e); 
          });  

        },
        /*
        * Gets data from user selected/tapped in mentions list. Fires the 
        * 'selected-user' event.
        *
        * @method selectedUser
        */        
        selectedUser: function(ev, detail, target) {
            shortname = target.attributes['data-shortname'].value;
            avatar = target.attributes['data-avatar'].value;
            section = target.attributes['data-location'].value;
            this.hideMentions(); // hide box
            this.fire('selected-user', {response: {'shortname': shortname, 'avatar': avatar, 'section': section}})
        },    
        /*
        * Show Mentions Box.
        *
        * @method showMentions
        */             
        showMentions: function() {
            this.$.mentionsContainer.style.display = "block";
        },
        /*
        * Hide Mentions Box.
        *
        * @method hideMentions
        */          
        hideMentions: function() {        
            this.$.mentionsContainer.style.display = "none";
        },
        /*
        * Emits the responseUsers's updates. Creates an URL to access the user's 
        * data from a services, like RestAPI, and changes the attribute of 
        * core-ajax called "#mentionsAjax".
        *
        * @method getMentions
        */        
        getMentions: function() {
            // TODO
            var mentionsAjax = this.$.mentionsAjax;
            var url = url + mention;
            var json_data = mentionsAjax.response;
            return json_data;
        },
        /*
        * Emits the responseTags's updates. Creates an URL to access the tag's 
        * data from a services, like RestAPI, and changes the attribute of 
        * core-ajax called "#tagsAjax".
        *
        * @method getTags
        */         
        getTags: function() {   
            // TODO        
            var tagsAjax = this.$.tagsAjax;
            var json_data = tagsAjax.response;
            return json_data;
        },
        /*
        * Returns true if a formatted hashtag has blank space or false if not.
        *
        * @method _hasWhiteSpace
        */ 
        _hasWhiteSpace: function(node) {
          var str = 'full';
          // Is need to have childNodes because this method is to test 'formatted'
          // hashtag
          if (node !== undefined && node.hasChildNodes()) {
              str = node.childNodes[0].textContent;
          }
          return /\s/g.test(str);
        },  
        /*
        * Restores the Caret to original position after changes.
        *
        * @param {Number} nodeIndex - The index of the node.
        * @param {Number} nodeOffset - The offset within the node.
        * @method restoreSelection
        */            
        _restoreSelection: function (nodeIndex, nodeOffset) {
            var textNode = null;
            var newNode = null;
            this._targetElem.focus();

            console.log("_restoreSelection [nodeIndex]:" + nodeIndex);
            console.log("_restoreSelection [nodeOffset]:" + nodeOffset);
       
            if (window.getSelection) //non IE and there is already a selection
            {
                var s = window.getSelection();

                // if pressed space within a hashtag (eg.: <em>XYZ</em>)
                if (this.isNewNode) { 
                  newNode = document.createTextNode('');
                  this.keyCode = '';
                }     

                if (this._targetElem.childNodes.length > 0) {  
                    
                    if (this._targetElem.childNodes[nodeIndex].hasChildNodes()) {
                      textNode = this._targetElem.childNodes[nodeIndex].childNodes[0];
                    } else {
                      textNode = this._targetElem.childNodes[nodeIndex];
                    }
                   
                    // get range
                    range = s.getRangeAt(0);

                    if (newNode) {
                      textNode = this._targetElem.childNodes[nodeIndex + 1]; // forward one
                      
                      if (textNode === undefined) {
                        textNode = this._targetElem.childNodes[nodeIndex]
                        range.setStartAfter(textNode);  
                        range.insertNode(newNode);
                        range.setStart(textNode, 1);
                        console.log("# nao tinha node na FRENTE "); 
                      } else {
                        range.setStartBefore(textNode);
                        range.insertNode(newNode);
                        range.setStart(textNode, 1);
                        console.log("# nao tinha node na ATRAS ");                         
                      }

                    } else {
                      console.log("# Restore has nodeOffset (2): " + nodeOffset);
                      console.log("# Restore has nodeOffset (2):  " + textNode.textContent);
                      range.setStart(textNode, nodeOffset);
                    }
                    // applied changes
                    s.removeAllRanges();
                    range.collapse(true); // Inpired by God! ;)
                    s.addRange(range);
                }
            }
        }, 
        /*
        * Gets the current index. We have based in selection.anchorNode to catch
        * the currentNode and childNodes to get listNodes.
        *
        * TODO: This method can be improved because this runs two for. 
        *
        @param {Node} currentNode - It's selection.anchorNode
        @param {ChildNodes} listNodes -  It's childNodes of the div#editable
        @method currentNodeIndexIs
        */        
        currentNodeIndexIs: function(currentNode, listNodes) {
          var nodeIndex = null;
          var node = null;

          // trying to verify in target
          for (var i = 0; i < listNodes.length; i++) {
            
            if (listNodes[i].hasChildNodes()) {
              node = listNodes[i].childNodes[0];
              
            } else {
              node = listNodes[i];  
            }
            
            if (node === currentNode) {
              nodeIndex = i;
              break;
            } else {
              nodeIndex = null;
            }

          }
          // trying to verify in shadow of the target. Shadow of the target is
          // the element "editableFilter" that receives a copy before changes.
          if (nodeIndex === null) {
            for (var j = 0; j < this.$.editableFilter.childNodes.length; j++) {
              
              if (this.$.editableFilter.childNodes[j].hasChildNodes()) {
                node = this.$.editableFilter.childNodes[j].childNodes[0];
              } else {
                node = this.$.editableFilter.childNodes[j];  
              }
                  
              if (node === currentNode) {
                nodeIndex = j;
                break;
              } else {
                nodeIndex = null;
              }

            }            
          }

          return nodeIndex
        },
        /*
        * Gets the caret position in plain text independently if (or not) exists 
        * node. The motivation this method is because the offset returned by Web
        * API is dependent of the node where is the caret. This is node agnostic!
        *
        @param {Number} nodeIndex 
        @param {Number} nodeOffset
        @param {ChildNodes} oldChildNodes
        @method inlinePosition
        */          
        inlinePosition: function(nodeIndex, nodeOffset, oldChildNodes) {
          // pressuponha onde vai cai basedo nos novos filhos
          this.superPos = '';
          var sumBefore = 0;
          console.log("## > inlinePosition: " + nodeIndex + " " + nodeOffset + " " + oldChildNodes);
          for (var i = nodeIndex - 1; i >= 0; i--) {
              console.log("## > length: " + oldChildNodes[i].textContent.length);
              sumBefore = sumBefore + oldChildNodes[i].textContent.length;
              console.log("## > sumBefore: " + sumBefore);
          }
          this.superPos = sumBefore + nodeOffset;
        },  
        /*
        * Returns the pair [index, offset] that is the caret position within of 
        * an element with nodes.
        *
        * @param {Number} superPos - the position of the caret in plain text view
        * @param {childNodes} newChildNodes - list of nodes returned by childNodes attrs.
        * @method inNodePosition
        */        
        inNodePosition: function(superPos, newChildNodes) {
          var childLengths = [];
          var segment = 0;
          var index, offset;

          for (var i = 0; i < newChildNodes.length; i++) {
            childLengths[i] = newChildNodes[i].textContent.length;
          }

          function indexAndOffset(point, line) {
            for (var i = 0; i < line.length; i++) {
                offset = point - segment;
                segment = segment + line[i];
                if (point <= segment) {
                  index = i;
                  break;
                }
            }
            segment = 0; // guarantee
            return [index, offset];
          }

          return indexAndOffset(superPos, childLengths);
        },
        checkInput: function () {
            var currentText = this._targetElem.textContent;
            var newText = this.formatter(currentText);
            var nodeIndex = null;
            var indexCurrent = null;
            var selection = document.getSelection();
            var range = selection.getRangeAt(0);
            var currentNode = range.startContainer
            var nodeOffset = range.startOffset;

            // check numbers of nodes
            nodes = this._targetElem.childNodes.length;
            // get current node index. "You are here". Before normalized.
            var indexCurrent = this.currentNodeIndexIs(currentNode, this._targetElem.childNodes);  
            // The target element is copied here
            this.$.editableFilter.innerHTML = this._targetElem.innerHTML;
            // The changes of the target element occurs here
            this._targetElem.innerHTML = newText;            
            // Defines the nodeIndex. Together with offset defines the position
            // of the caret. 
            nodesCurrent = this._targetElem.childNodes.length;
            // Gets node index and offset
            this.inlinePosition(indexCurrent, nodeOffset, this.$.editableFilter.childNodes);
            inNodePosition = this.inNodePosition(this.superPos, this._targetElem.childNodes);
            nodeIndex = inNodePosition[0];
            nodeOffset = inNodePosition[1]; 
            // check if exists blank space in formatted hashtag
            this.isNewNode = this._hasWhiteSpace(this.$.editableFilter.childNodes[indexCurrent]);  
            // By last...changes the shadow/copy of the target
            this.$.editableFilter.innerHTML = newText;
            // Restores the caret with this function
            console.log("[checkInput] nodeIndex and nodeOffset: ", + nodeIndex + " " + nodeOffset);
            console.log("[checkInput] nodes (before) and nodes (after): ", + nodes + " " + this._targetElem.childNodes.length);
            this._restoreSelection(nodeIndex, nodeOffset);

        }, 
        /*
        * Formats the string typed by user.
        * 
        * @param text: the string will be formatted
        * @method formatter
        * @return formatted string
        */                                 
        formatter: function(text) {
          var MAX_SIZE = 3;
          var unameHtagRegex = /(#|@){1}([A-Z]+[A-Z0-9]+)/ig;
          var linkRegex = this.linkRegex;
          var wrapTimeout = 0;
          var flatText = "",
              flatText2Hash = "",
              flatTextBefore = "",
              flatTextAfter = "";

          function wrapEm(match) {
              return "<em>" + match + "</em>";
          }
          function replaceHash(text) {
              return text.replace(unameHtagRegex, wrapEm);
          }
          function wrapLink(match) {
              return "<a target='_blank' href=" + match + ">" + match + "</a>";
          }
          function replaceLink(text) {
              return text.replace(linkRegex, wrapLink);
          } 

          return replaceHash(text);
        },
        /*
        * Sets th keyCode attribute.
        * 
        * @param {Number} e - event returned by pressed key
        * @method keysPressed
        */       
        keysPressed: function(e) {
          if (e.keyCode == 27) {
            this.unshowyMentionsBox();
          }
          this.keyCode = e.keyCode;
        }
      });
    })();
  </script>
</polymer-element>
