<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/core-ajax/core-ajax.html">

<!--
lp-input is a custom "fake input" to search users, hashtags by ajax and to 
format the content by using ordinary div#editable. Works like twitter, facebook,
slack inputs.

##### Example
      <div id="editable" contenteditable="true">
      </div>
      <lp-input target="editable"></lp-input>

@element lp-input
@blurb Element providing a ghost operator that makes input like twitter
@status beta
@homepage http://github.com/horacioibrahim/lp-input
-->

<polymer-element name="lp-input" attributes="target mentionsURL">
  <template>

      <link rel="stylesheet" href="lp-input.css">

      <!-- dropdown list of users 
           init search by @na...
      -->
      <div id="mentionsContainer">
          <ul id="ulMentionsContainer">
            <template repeat="{{user in Users}}">
              <li on-click="{{ selectedUser }}" data-shortname="{{ user.shortname }}"
              data-location="{{ user.location }}" data-avatar="{{ user.avatar }}">
                  <div class="mentions">
                      <div class="avatar">
                          <img src="{{user.avatar}}">
                      </div>
                      <div class="info">
                        <div class="username">{{ user.shortname }}</div>
                        <div class="details">{{ user.location }}</div> 
                      </div>
                  </div>          
              </li> 
            </template>
          </ul>
      </div>

      <!-- dropdown list of hashtags -->
      <div class="hashtags"></div>

      <!-- This elements will be a copy of the contentEditable passed by user. --> 
      <div id="editableFilter" contenteditable="true" hidden>
        <br/>
      </div> 

      <!-- ajax -->
      <core-ajax auto="true" id="mentionsAjax" url="{{ mentions }}"
      response="{{responseUsers}}"></core-ajax>
      
      <core-ajax id="tagsAjax" url="{{ tagsURL }}" response="{{responseTags}}"></core-ajax>


  </template>
  <script>
    (function () {
      Polymer('lp-input', {
        /**
        * Fired when a user is selected in mentions box.
        *
        * @event selected-user
        */        
        publish: {
          /**
          * The target is ID's value of the div.contentEditable.
          *
          * @attribute target
          * @type string
          * @default 'editable'
          */          
          target: "editable",
          __targetElem: null,
          tagRegex: /(#){1}([A-Z]+[A-Z0-9]+)/ig,
          userRegex: /(@){1}([A-Z]+[A-Z0-9]+)/ig,
          /**
          * The mentionsSearch is an URL to search users.
          *
          * @attribute mentionsSearch
          * @type string
          * @default ''
          */           
          mentionsURL: '',
          /*
          * The isNewNode persists boolean that contains info if the typed data 
          * must be to generate a new node. This occurs when the user types 
          * white-space inner a node-hashtag.
          *
          * @attribute isNewNode
          * @type boolean
          * @default false
          */ 
          isNewNode: false,
          /*
          * The isChar is used together with "isKey" to check if the input inserted
          * by user is a char or only a key pressed. Because accents "aren't"
          * chars.
          *
          * @attribute isChar
          * @type boolean
          * @default false
          */ 
          isChar: false,
          /*
          * The isKey is used together with "isChar" to check if the input inserted
          * by user is a char or only a key pressed. Because accents "aren't"
          * chars.
          *
          * @attribute isChar
          * @type boolean
          * @default false
          */           
          isKey: false,
          valueText: null,
          Users: []
        },    
        ready: function () {
          // get the div#editable passed by user
          this._targetElem = document.querySelector('#' + this.target);
          // get current custom element object
          var fakeThis = document.querySelector('lp-input');
          // listen by inputs
          this._targetElem.addEventListener('input', function(event) {
             fakeThis.checkInput();
          });          
          this._targetElem.addEventListener('keyup', function(event) {
             // fakeThis.isKey = true;
             fakeThis.valueText = this.textContent; 
          });                  
        },
        /*
        * Checks if textContent of the contentEditable was changed. If the input
        * is a char isKey and isChar will be true, therefore the "checkIinput" is
        * called.
        *
        * @method valueTextChanged
        */          
        valueTextChanged: function() {
          // console.log("# Entrou valueTextChanged");
         /*  if (this.isKey == this.isChar) {
            this.checkInput();  
          }
          this.isKey = false;
          this.isChar = false;
          */
          var selection = document.getSelection();
          var range = selection.getRangeAt(0);
          var currentNode = range.startContainer;
          // get current node index. "You are here". Before normalized.
          var indexCurrent = this.currentNodeIndexIs(currentNode, this._targetElem.childNodes);
          var nodeValue = currentNode.nodeValue;
          if (/^@/g.test(nodeValue) && nodeValue.length > 3 ) {
              this.getMentions(nodeValue);
              this.addEventListener('selected-user', function(ev) {
                currentNode.nodeValue = '@' + ev.detail.response.shortname;
                this._restoreSelection(indexCurrent, currentNode.nodeValue.length);
              });
          }
        }, 
        /*
        * Gets data from user selected/tapped in mentions list. Fires the 
        * 'selected-user' event.
        *
        * @method selectedUser
        */        
        selectedUser: function(ev, detail, target) {
            shortname = target.attributes['data-shortname'].value;
            avatar = target.attributes['data-avatar'].value;
            section = target.attributes['data-location'].value;
            this.hideMentions(); // hide box
            this.fire('selected-user', {response: {'shortname': shortname, 'avatar': avatar, 'section': section}})
        },    
        /*
        * Show Mentions Box.
        *
        * @method showMentions
        */             
        showMentions: function() {
          this.$.mentionsContainer.style.display = "block";
        },
        /*
        * Hide Mentions Box.
        *
        * @method hideMentions
        */          
        hideMentions: function() {        
            this.$.mentionsContainer.style.display = "none";
        },
        /*
        * Emits the responseUsers's updates. Creates an URL to access the user's 
        * data from a services, like RestAPI, and changes the attribute of 
        * core-ajax called "#mentionsAjax".
        *
        * @method getMentions
        */        
        getMentions: function(expr) {
            var mentionsAjax = this.$.mentionsAjax;
            var url = '';
                        
            if (/\/$/.test(this.mentionsURL)) {
              url = this.mentionsURL + expr;
            } else {
              url = this.mentionsURL.concat('/', expr);
            }
            this.mentions = url;

            // waiting... and ...update Users
            this.addEventListener('core-response', function(){
               data = JSON.parse(this.responseUsers);
               this.Users = data.Users;
            });

            this.showMentions();
        },
        /*
        * Emits the responseTags's updates. Creates an URL to access the tag's 
        * data from a services, like RestAPI, and changes the attribute of 
        * core-ajax called "#tagsAjax".
        *
        * @method getTags
        */         
        getTags: function() {   
            // TODO        
            var tagsAjax = this.$.tagsAjax;
            var json_data = tagsAjax.response;
            return json_data;
        },
        /*
        * Returns true if a formatted hashtag has blank space or false if not.
        *
        * @method _hasWhiteSpace
        */ 
        _hasWhiteSpace: function(node) {
          var str = 'full';
          // Is need to have childNodes because this method is to test 'formatted'
          // hashtag
          if (node !== undefined && node.hasChildNodes()) {
              str = node.childNodes[0].textContent;
          }
          return /\s|&nbsp;/g.test(str);
        },  
        /*
        * Restores the Caret to original position after changes.
        *
        * @param {Number} nodeIndex - The index of the node.
        * @param {Number} nodeOffset - The offset within the node.
        * @method restoreSelection
        */            
        _restoreSelection: function (nodeIndex, nodeOffset) {
            var textNode = null;
            var newNode = null;
            this._targetElem.focus();

       
            if (window.getSelection) //non IE and there is already a selection
            {
                var s = window.getSelection();

                // if pressed space within a hashtag (eg.: <em>XYZ</em>)
                if (this.isNewNode) { 
                  newNode = document.createTextNode('');
                }     

                if (this._targetElem.childNodes.length > 0) {  
                    
                    if (this._targetElem.childNodes[nodeIndex].hasChildNodes()) {
                      textNode = this._targetElem.childNodes[nodeIndex].childNodes[0];
                    } else {
                      textNode = this._targetElem.childNodes[nodeIndex];
                    }
                   
                    // get range
                    range = s.getRangeAt(0);

                    if (newNode) {
                      textNode = this._targetElem.childNodes[nodeIndex + 1]; // forward one
                      
                      if (textNode === undefined) {
                        textNode = this._targetElem.childNodes[nodeIndex]
                        range.setStartAfter(textNode);  
                        range.insertNode(newNode);
                        range.setStart(textNode, 1);
                      } else {
                        range.setStartBefore(textNode);
                        range.insertNode(newNode);
                        range.setStart(textNode, 1);
                      }

                    } else {
                      range.setStart(textNode, nodeOffset);
                    }
                    // applied changes
                    s.removeAllRanges();
                    range.collapse(true); // Inpired by God! ;)
                    s.addRange(range);
                }
            }
        }, 
        /*
        * Gets the current index. We have based in selection.anchorNode to catch
        * the currentNode and childNodes to get listNodes.
        *
        * TODO: This method can be improved because this runs two for. 
        *
        @param {Node} currentNode - It's selection.anchorNode
        @param {ChildNodes} listNodes -  It's childNodes of the div#editable
        @method currentNodeIndexIs
        */        
        currentNodeIndexIs: function(currentNode, listNodes) {
          var nodeIndex = null;
          var node = null;

          // trying to verify in target
          for (var i = 0; i < listNodes.length; i++) {
            
            if (listNodes[i].hasChildNodes()) {
              node = listNodes[i].childNodes[0];
              
            } else {
              node = listNodes[i];  
            }
            
            if (node === currentNode) {
              nodeIndex = i;
              break;
            } else {
              nodeIndex = null;
            }

          }
          // trying to verify in shadow of the target. Shadow of the target is
          // the element "editableFilter" that receives a copy before changes.
          if (nodeIndex === null) {
            for (var j = 0; j < this.$.editableFilter.childNodes.length; j++) {
              
              if (this.$.editableFilter.childNodes[j].hasChildNodes()) {
                node = this.$.editableFilter.childNodes[j].childNodes[0];
              } else {
                node = this.$.editableFilter.childNodes[j];  
              }
                  
              if (node === currentNode) {
                nodeIndex = j;
                break;
              } else {
                nodeIndex = null;
              }

            }            
          }

          return nodeIndex
        },
        /*
        * Gets the caret position in plain text independently if (or not) exists 
        * node. The motivation this method is because the offset returned by Web
        * API is dependent of the node where is the caret. This is node agnostic!
        *
        @param {Number} nodeIndex 
        @param {Number} nodeOffset
        @param {ChildNodes} oldChildNodes
        @method inlinePosition
        */          
        inlinePosition: function(nodeIndex, nodeOffset, oldChildNodes) {
          // pressuponha onde vai cai basedo nos novos filhos
          this.superPos = 0;
          var sumBefore = 0;
          for (var i = nodeIndex - 1; i >= 0; i--) { // loop on nodes
              n = oldChildNodes[i];
              sumBefore = sumBefore + oldChildNodes[i].textContent.length;
          }
          this.superPos = sumBefore + nodeOffset;
        },  
        /*
        * Returns the pair [index, offset] that is the caret position within of 
        * an element with nodes.
        *
        * @param {Number} superPos - the position of the caret in plain text view
        * @param {childNodes} newChildNodes - list of nodes returned by childNodes attrs.
        * @method inNodePosition
        */        
        inNodePosition: function(superPos, newChildNodes) {
          var childLengths = [];
          var segment = 0;
          var index, offset;

          for (var i = 0; i < newChildNodes.length; i++) {
            childLengths[i] = newChildNodes[i].textContent.length;
          }

          function indexAndOffset(point, line) {
            for (var i = 0; i < line.length; i++) {
                offset = point - segment;
                segment = segment + line[i];
                if (point <= segment) {
                  index = i;
                  break;
                }
            }
            segment = 0; // guarantee
            return [index, offset];
          }

          return indexAndOffset(superPos, childLengths);
        },
        checkInput: function () {
            var currentText = this._targetElem.textContent; // sanitize
            var newText = this.formatter(currentText);
            var nodeIndex = null;
            var indexCurrent = null;
            var selection = document.getSelection();
            var range = selection.getRangeAt(0);
            var currentNode = range.startContainer
            var nodeOffset = range.startOffset;

            // check numbers of nodes
            nodes = this._targetElem.childNodes.length;
            // get current node index. "You are here". Before normalized.
            var indexCurrent = this.currentNodeIndexIs(currentNode, this._targetElem.childNodes);  
            // The target element is copied here
            this.$.editableFilter.innerHTML = this._targetElem.innerHTML;
            // The changes of the target element occurs here  
            this._targetElem.innerHTML =  String(newText);
            // Defines the nodeIndex. Together with offset defines the position
            // of the caret.
            nodesCurrent = this._targetElem.childNodes.length;
            // Gets node index and offset
            this.inlinePosition(indexCurrent, nodeOffset, this.$.editableFilter.childNodes);
            inNodePosition = this.inNodePosition(this.superPos, this._targetElem.childNodes);
            nodeIndex = inNodePosition[0];
            nodeOffset = inNodePosition[1]; 
            // check if exists blank space in formatted hashtag
            this.isNewNode = this._hasWhiteSpace(this.$.editableFilter.childNodes[indexCurrent]);  
            // By last...changes the shadow/copy of the target
            this.$.editableFilter.innerHTML = newText;
            // Restores the caret with this function
            // console.log("[checkInput] nodeIndex and nodeOffset: ", + nodeIndex + " " + nodeOffset);
            // console.log("[checkInput] nodes (before) and nodes (after): ", + nodes + " " + this._targetElem.childNodes.length);            
            this._restoreSelection(nodeIndex, nodeOffset);
        }, 
        /*
        * Formats the string typed by user.
        * 
        * @param text: the string will be formatted
        * @method formatter
        * @return formatted string
        */                                 
        formatter: function(text) {
          var unameHtagRegex = /(#|@){1}([A-Z]+[A-Z0-9]+)/ig;

          function wrapEm(match) {
              return "<em>" + match + "</em>";
          }
          function replaceHash(text) {
              return text.replace(unameHtagRegex, wrapEm);
          }
          newText = replaceHash(text);
          newText = newText.replace(/\s/g, '&nbsp;'); // use <meta charset="UTF-8">
          return newText;
        },
        /*
        * Sets the keyCode attribute.
        * 
        * @param {Number} e - event returned by pressed key
        * @method keysPressed
        */       
        keysPressed: function(e) {
          if (e.keyCode == 27) {
            this.unshowyMentionsBox();
          }
          this.keyCode = e.keyCode;
        },       
      });
    })();
  </script>
</polymer-element>
